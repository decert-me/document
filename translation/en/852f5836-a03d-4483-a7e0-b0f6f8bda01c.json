{
    "title": "Write ERC721 NFT Contract",
    "description": "The ERC721 standard represents non-fungible tokens (NFTs), which provide on-chain representation for unique assets. From digital artwork to virtual property, the concept of NFTs is rapidly gaining worldwide recognition. Understanding and being able to implement the ERC721 standard is crucial for blockchain developers. Through this challenge, you can not only become familiar with Solidity programming, but also understand how ERC721 contracts work.",
    "questions": [
        {
            "title": "Write ERC721 NFT Contract",
            "description": "## Introduction\n\nThe ERC721 standard represents non-fungible tokens (NFTs), which provide on-chain representation for unique assets. From digital artwork to virtual property, the concept of NFTs is rapidly gaining worldwide recognition. Understanding and being able to implement the ERC721 standard is crucial for blockchain developers. Through this challenge, you can not only become familiar with Solidity programming, but also understand how ERC721 contracts work.\n\n## Objective\n\nYour task is to create a smart contract that follows the ERC721 standard, which can be used to mint and trade NFTs on the Ethereum blockchain.\n\n## Related Resources\n\nTo help complete this challenge, the following resources may be useful:\n• [EIP-721 Standard](https://eips.ethereum.org/EIPS/eip-721)\n• [OpenZeppelin ERC721 Smart Contract Library](https://docs.openzeppelin.com/contracts/5.x/erc721)\n\n## Note\n\n* When writing the contract, it is necessary to adhere to the ERC721 standard, as well as consider security to ensure that transfer and authorization functions operate correctly at all times.\n* The code template already includes the basic framework, and you only need to write your code in the section marked as `/**code*/`. Do not modify the existing content! * Before submission, ensure that all relevant test cases have been passed\n",
            "type": "coding",
            "score": 100,
            "languages": [
                "Solidity"
            ],
            "code_snippets": [
                {
                    "lang": "Solidity",
                    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\ncontract BaseERC721 {\n    using Strings for uint256;\n    using Address for address;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Token baseURI\n    string private _baseURI;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Initializes the contract by setting a `name`, a `symbol` and a `baseURI` to the token collection.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        string memory baseURI_\n    ) {\n        /**code*/\n\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f;   // ERC165 Interface ID for ERC721Metadata\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view returns (string memory) {\n        /**code*/\n\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view returns (string memory) {\n        /**code*/\n        \n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        require(\n            /**code*/,\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        // should return baseURI\n        /**code*/\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` must not exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function mint(address to, uint256 tokenId) public {\n        require(/**code*/ , \"ERC721: mint to the zero address\");\n        require(/**code*/, \"ERC721: token already minted\");\n\n        /**code*/\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        /**code*/\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        /**code*/\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(/**code*/, \"ERC721: approval to current owner\");\n\n        require(\n            /**code*/,\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n       _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(\n            /**code*/,\n            \"ERC721: approved query for nonexistent token\"\n        );\n\n        /**code*/\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public {\n        address sender = msg.sender;\n        require(/**code*/, \"ERC721: approve to caller\");\n        \n        /**code*/\n\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) public view returns (bool) {\n        /**code*/\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public {\n        require(\n            _isApprovedOrOwner(msg.sender, tokenId),\n            \"ERC721: transfer caller is not owner nor approved\"\n        );\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal {\n        _transfer(from, to, tokenId);\n        require(\n            _checkOnERC721Received(from, to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        /**code*/\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view returns (bool) {\n        require(\n            /**code*/,\n            \"ERC721: operator query for nonexistent token\"\n        );\n\n        /**code*/\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        require(\n           /**code*/,\n            \"ERC721: transfer from incorrect owner\"\n        );\n\n        require(/**code*/, \"ERC721: transfer to the zero address\");\n\n        /**code*/\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        /**code*/\n\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try\n                IERC721Receiver(to).onERC721Received(\n                    msg.sender,\n                    from,\n                    tokenId,\n                    _data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\n                        \"ERC721: transfer to non ERC721Receiver implementer\"\n                    );\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n}\n\ncontract BaseERC721Receiver is IERC721Receiver {\n    constructor() {}\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}",
                    "correctAnswer": "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"
                }
            ],
            "spj_code": [
                {
                    "frame": "Hardhat",
                    "code": "const { expect } = require('chai');\nconst { ethers } = require('hardhat');\n\n\ndescribe(\"BaseERC721\", async () => {\n    let contract, contractAddr;\n    let receivercontract, receivercontractAddr;\n    let accounts, owner;\n    const name = 'BaseERC721';\n    const symbol = 'BERC721';\n    const baseURI = 'https://images.example.com/';\n\n    const randomAccount = ethers.Wallet.createRandom();\n    const randomAddr = randomAccount.address;\n    const ZeroAddress = ethers.constants.AddressZero;\n\n\n    async function init() {\n        // 部署 BaseERC721\n        accounts = await ethers.getSigners();\n        owner = accounts[0];\n\n        {\n            const factory = await ethers.getContractFactory('BaseERC721');\n            contract = await factory.deploy(...[name, symbol, baseURI]);\n            await contract.deployed();\n        }\n        {\n            const factory = await ethers.getContractFactory('BaseERC721Receiver');\n            receivercontract = await factory.deploy();\n            await receivercontract.deployed();\n        }\n\n        contractAddr = contract.address;\n        receivercontractAddr = receivercontract.address;\n    }\n\n    beforeEach(async () => {\n        await init();\n    })\n\n    describe(\"IERC721Metadata\", async () => {\n        it(\"name\", async () => {\n            expect(await contract.name()).to.equal(name);\n        });\n\n        it(\"symbol\", async () => {\n            expect(await contract.symbol()).to.equal(symbol);\n        });\n\n        describe(\"tokenURI\", async () => {\n            it(\"URI query for nonexistent token should revert\", async () => {\n                const NONE_EXISTENT_TOKEN_ID = 1234\n                await expect(\n                    contract.tokenURI(NONE_EXISTENT_TOKEN_ID)\n                ).to.be.revertedWith(\"ERC721Metadata: URI query for nonexistent token\");\n            });\n\n            it('Should return baseURI when tokenId exists', async function () {\n                const tokenId = 1\n                await contract.connect(owner).mint(randomAddr, tokenId);\n\n                const expectURI = baseURI + String(tokenId);\n                expect(await contract.tokenURI(tokenId)).to.equal(expectURI);\n            });\n        })\n    })\n\n    describe(\"IERC721\", async () => {\n        describe(\"balanceOf \", async () => {\n            it(\"balanceOf\", async () => {\n                // before should be 0\n                const beforeBalance = await contract.balanceOf(randomAddr);\n                expect(beforeBalance).to.equal(0);\n\n                // mint\n                await contract.connect(owner).mint(randomAddr, 1);\n\n                // after should be 1\n                const afterBalance = await contract.balanceOf(randomAddr);\n                expect(afterBalance).to.equal(1);\n            });\n        });\n\n        describe(\"ownerOf \", async () => {\n            it(\"ownerOf\", async () => {\n                const tokenId = 1;\n                const receiver = randomAddr;\n                // before should be 0 address\n                const beforeBalance = await contract.ownerOf(tokenId);\n                expect(beforeBalance).to.equal(ZeroAddress);\n\n                // mint\n                await contract.connect(owner).mint(receiver, 1);\n\n                // after should be receiver\n                const holder = await contract.ownerOf(tokenId);\n                expect(holder).to.equal(receiver);\n            });\n        });\n\n        describe('approve', function () {\n            it('owner should approve successfully', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); //mint to self\n\n                const to = randomAddr;\n                await expect(\n                    contract.connect(owner).approve(to, tokenId)\n                ).to.emit(contract, \"Approval\")\n                    .withArgs(owner.address, to, tokenId);\n\n                // getApproved\n                expect(await contract.getApproved(tokenId)).to.equal(to);\n            });\n\n            it('approved account should approve successfully', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); //mint to self\n\n                // setApprovalForAll accounts1\n                const caller = accounts[1];\n                await contract.connect(owner).setApprovalForAll(caller.address, true)\n\n                // accounts1 arpprove owner's tokenId[1] to randomAddr\n                const to = randomAddr;\n                expect(\n                    await contract.connect(caller).approve(to, tokenId)\n                ).to.be.ok;\n\n                // getApproved\n                expect(await contract.getApproved(tokenId)).to.equal(to);\n            });\n\n            it('Approve to current owner should revert', async function () {\n                // mint token first\n                const tokenId = 1;\n                const receiver = owner.address; //self\n                await contract.connect(owner).mint(receiver, tokenId);\n\n                await expect(\n                    contract.connect(owner).approve(receiver, tokenId)\n                ).to.be.revertedWith(\"ERC721: approval to current owner\");\n            });\n\n            it('Not owner nor approved token approveal should revert', async function () {\n                // mint token first\n                const tokenId = 1;\n                const receiver = owner.address; //self\n                await contract.connect(owner).mint(receiver, tokenId);\n\n                const otherAccount = accounts[1]; //not owner or approved\n                await expect(\n                    contract.connect(otherAccount).approve(randomAddr, tokenId)\n                ).to.be.revertedWith(\"ERC721: approve caller is not owner nor approved for all\");\n            });\n        });\n\n        describe('getApproved', function () {\n            it('should return approval address', async function () {\n                // mint token first\n                const tokenId = 1;\n                const receiver = owner.address; //self\n                await contract.connect(owner).mint(receiver, tokenId);\n\n                // approve\n                const approvedAddr = randomAddr;\n                await contract.connect(owner).approve(randomAddr, tokenId);\n\n                expect(await contract.getApproved(tokenId)).to.equal(approvedAddr);\n            });\n\n            it('Approved query for nonexistent token should revert', async function () {\n                const tokenId = 1; // not exists\n\n                await expect(\n                    contract.getApproved(tokenId)\n                ).to.be.revertedWith('ERC721: approved query for nonexistent token');\n            });\n        });\n\n        describe('setApprovalForAll', function () {\n            it('setApprovalForAll true/flase', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                const spender = randomAddr;\n\n                // set true\n                await contract.connect(owner).setApprovalForAll(spender, true);\n                expect(await contract.isApprovedForAll(owner.address, spender)).to.equal(true);\n\n                // set false\n                await contract.connect(owner).setApprovalForAll(spender, false);\n                expect(await contract.isApprovedForAll(owner.address, spender)).to.equal(false);\n            });\n\n            it('Approve to self should revert', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                await expect(\n                    contract.connect(owner).setApprovalForAll(owner.address, true) // approve to self\n                ).to.be.revertedWith(\"ERC721: approve to caller\");\n            });\n        });\n\n        describe('transferFrom', function () {\n            it('owner account should succeed and balance should change', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                const to = randomAddr;\n\n                // balance change\n                await expect(\n                    contract.connect(owner).transferFrom(owner.address, to, tokenId)\n                ).to.changeTokenBalances(contract, [owner.address, to], [-1, 1]);\n            });\n\n            it('approved account should succeed and balance should change', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                const to = randomAddr;\n\n                // approve\n                const spenderAccout = accounts[1];\n                await contract.connect(owner).approve(spenderAccout.address, tokenId)\n\n                // transfer and balance should change\n                await expect(\n                    contract.connect(spenderAccout).transferFrom(owner.address, to, tokenId)\n                ).to.changeTokenBalances(contract, [owner.address, to], [-1, 1]);\n            });\n\n            it('approvedForAll account should succeed and balance should change', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                const to = randomAddr;\n\n                // setApprovalForAll\n                const spenderAccout = accounts[1];\n                await contract.connect(owner).setApprovalForAll(spenderAccout.address, true)\n\n                // transfer and balance should change\n                await expect(\n                    contract.connect(spenderAccout).transferFrom(owner.address, to, tokenId)\n                ).to.changeTokenBalances(contract, [owner.address, to], [-1, 1]);\n            });\n\n            it('not owner nor approved should revert', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                const to = randomAddr;\n                const otherAccount = accounts[1]; //not owner or approved\n                await expect(\n                    contract.connect(otherAccount).transferFrom(owner.address, to, tokenId)\n                ).to.revertedWith(\"ERC721: transfer caller is not owner nor approved\");\n            });\n\n            it('none exists tokenId should revert', async function () {\n                const NONE_EXISTENT_TOKEN_ID = Math.ceil(Math.random() * 1000000);\n                const to = randomAddr;\n                await expect(\n                    contract.connect(owner).transferFrom(owner.address, to, NONE_EXISTENT_TOKEN_ID)\n                ).to.revertedWith(\"ERC721: operator query for nonexistent token\");\n            });\n\n            it('to zero address should revert', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                const to = ZeroAddress;\n                await expect(\n                    contract.connect(owner).transferFrom(owner.address, to, tokenId)\n                ).to.revertedWith(\"ERC721: transfer to the zero address\");\n            });\n\n            it('from != caller.address should revert', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                const to = randomAddr;\n                const from = accounts[1].address;\n                await expect(\n                    contract.connect(owner).transferFrom(from, to, tokenId)\n                ).to.revertedWith(\"ERC721: transfer from incorrect owner\");\n            });\n\n            it('should revoke old approval when token transfered', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                const to = randomAddr;\n\n                // approve\n                const spender = accounts[1].address;\n                await contract.connect(owner).approve(spender, tokenId);\n                expect(await contract.getApproved(tokenId)).to.equal(spender); //before\n\n                // transfer\n                await contract.connect(owner).transferFrom(owner.address, to, tokenId);\n\n                // should revoke approval\n                expect(await contract.getApproved(tokenId)).to.equal(ZeroAddress); // after\n            });\n        });\n\n        describe('safeTransferFrom', function () {\n            // same as transferFrom\n            it('owner should succeed and balance should change', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                const to = randomAddr;\n\n                // balance change\n                await expect(\n                    contract.connect(owner)[\"safeTransferFrom(address,address,uint256)\"](owner.address, to, tokenId)\n                ).to.changeTokenBalances(contract, [owner.address, to], [-1, 1]);\n            });\n\n            // same as transferFrom\n            it('approved should succeed and balance should change', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                const to = randomAddr;\n\n                // approve\n                const spenderAccout = accounts[1];\n                await contract.connect(owner).approve(spenderAccout.address, tokenId)\n\n                // transfer and balance should change\n                await expect(\n                    contract.connect(spenderAccout)[\"safeTransferFrom(address,address,uint256)\"](owner.address, to, tokenId)\n                ).to.changeTokenBalances(contract, [owner.address, to], [-1, 1]);\n            });\n\n            // same as transferFrom\n            it('not owner nor approved should revert', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                const to = randomAddr;\n                const otherAccount = accounts[1]; //not owner or approved\n                await expect(\n                    contract.connect(otherAccount)[\"safeTransferFrom(address,address,uint256)\"](owner.address, to, tokenId)\n                ).to.revertedWith(\"ERC721: transfer caller is not owner nor approved\");\n            });\n\n            it('transfer to none ERC721Receiver implementer should revert', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                const to = contractAddr; // not support ERC721Receiver\n                await expect(\n                    contract.connect(owner)[\"safeTransferFrom(address,address,uint256)\"](owner.address, to, tokenId)\n                ).to.revertedWith(\"ERC721: transfer to non ERC721Receiver implementer\");\n            });\n\n            it('transfer to ERC721Receiver implementer should succeed', async function () {\n                // mint token first\n                const tokenId = 1;\n                await contract.connect(owner).mint(owner.address, tokenId); // mint to self\n\n                const to = receivercontractAddr; // support ERC721Receiver\n                expect(\n                    await contract.connect(owner)[\"safeTransferFrom(address,address,uint256)\"](owner.address, to, tokenId)\n                ).to.be.ok;\n            });\n        });\n    })\n\n    describe(\"mint\", async () => {\n        it('mint succeed should update balance', async function () {\n            const tokenId = 1;\n\n            await expect(\n                contract.connect(owner).mint(randomAddr, tokenId)\n            ).to.changeTokenBalance(contract, randomAddr, 1);\n        });\n\n        it(\"mint to the zero address should revert\", async () => {\n            const tokenId = 1;\n\n            await expect(\n                contract.connect(owner).mint(ZeroAddress, tokenId)\n            ).to.be.revertedWith(\"ERC721: mint to the zero address\");\n        });\n\n        it(\"mint repeated tokenId should revert\", async () => {\n            const tokenId = 1;\n\n            // first mint\n            await contract.connect(owner).mint(randomAddr, tokenId)\n\n            // sencond\n            await expect(\n                contract.connect(owner).mint(randomAddr, tokenId)\n            ).to.be.revertedWith(\"ERC721: token already minted\");\n        });\n    })\n});"
                }
            ]
        }
    ]
}
