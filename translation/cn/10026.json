{
    "title": "编写 ERC20 token 合约",
    "description": "ERC20 是以太坊区块链上最常用的 Token 合约标准。通过这个挑战，你不仅可以熟悉 Solidity 编程，而且可以了解 ERC20 Token 合约的工作原理。",
    "creator": "0xB2fB0B6A80Ce4eE741e7053A0e78C823a3Ba807B",
    "content": "",
    "questions": [
        {
            "title": "编写 ERC20 token 合约",
            "description": "## 介绍\n\nERC20 是以太坊区块链上最常用的 Token 合约标准。通过这个挑战，你不仅可以熟悉 Solidity 编程，而且可以了解 ERC20 Token 合约的工作原理。\n\n## 目标\n\n完善合约，实现以下功能：\n\n1. 设置 Token 名称（name）：\"BaseERC20\"\n2. 设置 Token 符号（symbol）：\"BERC20\"\n3. 设置 Token 小数位decimals：18\n4. 设置 Token 总量（totalSupply）:100,000,000\n5. 允许任何人查看任何地址的 Token 余额（balanceOf）\n6. 允许 Token 的所有者将他们的 Token 发送给任何人（transfer）；转帐超出余额时抛出异常(require),并显示错误消息 “ERC20: transfer amount exceeds balance”。\n7. 允许 Token 的所有者批准某个地址消费他们的一部分Token（approve）\n8. 允许任何人查看一个地址可以从其它账户中转账的代币数量（allowance）\n9. 允许被授权的地址消费他们被授权的 Token 数量（transferFrom）；\\\n   转帐超出余额时抛出异常(require)，异常信息：“ERC20: transfer amount exceeds balance”\\\n   转帐超出授权数量时抛出异常(require)，异常消息：“ERC20: transfer amount exceeds allowance”。\n\n注意：\n在编写合约时，需要遵循 ERC20 标准，此外也需要考虑到安全性，确保转账和授权功能在任何时候都能正常运行无误。\\\n代码模板中已包含基础框架，只需要在标记为“Write your code here”的地方编写你的代码。不要去修改已有内容！\n\n希望你能用一段优雅、高效和安全的代码，完成这个挑战。\n",
            "type": "coding",
            "score": 100,
            "languages": [
                "Solidity"
            ],
            "code_snippets": [
                {
                    "lang": "Solidity",
                    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\ncontract BaseERC20 {\n    string public name; \n    string public symbol; \n    uint8 public decimals; \n\n    uint256 public totalSupply; \n\n    mapping (address => uint256) balances; \n\n    mapping (address => mapping (address => uint256)) allowances; \n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor() public {\n        // write your code here\n        // set name,symbol,decimals,totalSupply\n\n        balances[msg.sender] = totalSupply;  \n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        // write your code here\n\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        // write your code here\n\n\n        emit Transfer(msg.sender, _to, _value);  \n        return true;   \n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        // write your code here\n\n        \n        emit Transfer(_from, _to, _value); \n        return true; \n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        // write your code here\n\n\n        emit Approval(msg.sender, _spender, _value); \n        return true; \n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {   \n        // write your code here     \n\n    }\n}",
                    "correctAnswer": "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"
                }
            ],
            "spj_code": [
                {
                    "frame": "Hardhat",
                    "code": "const { expect } = require('chai');\nconst { ethers } = require('hardhat');\n\n\ndescribe(\"BaseERC20\", async () => {\n    let contract;\n    let accounts, owner;\n    const name = 'BaseERC20';\n    const symbol = 'BERC20';\n    const decimals = 18;\n    const totalSupply = ethers.utils.parseUnits('1.0', decimals).mul(100000000); // 100 million\n    const randomAccount = ethers.Wallet.createRandom();\n    const randomAddr = randomAccount.address;\n\n\n    async function init() {\n        // 部署 BaseERC20\n        accounts = await ethers.getSigners();\n        owner = accounts[0];\n\n        const factory = await ethers.getContractFactory('BaseERC20');\n        contract = await factory.deploy();\n        await contract.deployed();\n    }\n\n    beforeEach(async () => {\n        await init();\n    })\n\n    describe(\"base\", async () => {\n        it(\"name\", async () => {\n            expect(await contract.name()).to.equal(name);\n        });\n\n        it(\"symbol\", async () => {\n            expect(await contract.symbol()).to.equal(symbol);\n        });\n\n        it(\"decimals\", async () => {\n            expect(await contract.decimals()).to.equal(decimals);\n        });\n    })\n\n    describe(\"totalSupply \", async () => {\n        it(\"totalSupply\", async () => {\n            const _totalSupply = await contract.totalSupply();\n            expect(_totalSupply).to.equal(totalSupply);\n        });\n    });\n\n    describe(\"balanceOf \", async () => {\n        it(\"balanceOf\", async () => {\n            const balance = await contract.balanceOf(owner.address);\n            expect(balance).to.equal(totalSupply);\n        });\n    });\n\n    describe(\"transfer\", function () {\n        it(\"Should fail if sender doesn’t have enough balance\", async function () {\n            const curBalance = await contract.balanceOf(owner.address);\n            const transAmount = curBalance.add(1);\n\n            await expect(\n                contract.connect(owner).transfer(randomAddr, transAmount)\n            ).to.be.revertedWith(\"ERC20: transfer amount exceeds balance\");\n        });\n\n        it(\"Should update balances after transfers\", async function () {\n            // Transfer 100 tokens from owner to randomAddr.\n            await expect(\n                contract.transfer(randomAddr, 100)\n            ).to.changeTokenBalances(contract, [owner.address, randomAddr], [-100, 100]);\n        });\n    });\n\n    describe('Approval', function () {\n        it('Should set an approval amount for delegated tranfer', async function () {\n            const amount = 100\n            await contract.connect(owner).approve(randomAddr, amount);\n            expect(await contract.allowance(owner.address, randomAddr)).to.equal(amount);\n        });\n    });\n\n    describe('Allowance', function () {\n        // 'Should set an approval amount for delegated tranfer',see above case\n\n        it('Should update allowance after transferFrom', async function () {\n            let sender = accounts[1];\n            let recipient = randomAddr;\n            let approveAmount = 100;\n            let usedAmout = approveAmount/2;\n            let leftAmount = approveAmount - usedAmout;\n\n            await contract.connect(owner).approve(sender.address, approveAmount);\n\n            await contract.connect(sender).transferFrom(owner.address, recipient, usedAmout);\n\n            const afterAllowance = await contract.allowance(owner.address, sender.address);\n\n            expect(afterAllowance).to.equal(leftAmount);\n        });\n    });\n\n    describe('transferFrom', function () {\n        // 'Should update allowance after transferFrom',see above case\n\n        it('Should transfer the tokens from sender to recipient', async function () {\n            let sender = accounts[1];\n            let recipient = randomAddr;\n            let amount = 100;\n\n            await contract.connect(owner).approve(sender.address, amount);\n            await contract.connect(sender).transferFrom(owner.address, recipient, amount);\n\n            expect(await contract.balanceOf(recipient)).to.equal(amount);\n        });\n\n        it('Should fail if sender doesn’t have enough tokens', async function () {\n            let sender = accounts[1];\n            let recipient = randomAddr;\n            let allowanceAmount = totalSupply.add(1);\n\n            await contract.connect(owner).approve(sender.address, allowanceAmount);\n            await expect(contract.connect(sender).transferFrom(owner.address, recipient, allowanceAmount)).to.be.revertedWith('ERC20: transfer amount exceeds balance');\n        });\n\n        it('Should fail if trying to transfer more tokens than approved', async function () {\n            let sender = accounts[1];\n            let recipient = randomAddr;\n            let allowanceAmount = 100;\n            let transferAmount = 101; // more than approved\n\n            await contract.connect(owner).approve(sender.address, allowanceAmount);\n            await expect(contract.connect(sender).transferFrom(owner.address, recipient, transferAmount)).to.be.revertedWith('ERC20: transfer amount exceeds allowance');\n        });\n    });\n});"
                }
            ]
        }
    ],
    "answers": "Nxo9AD0W",
    "startTime": "2023-12-25T06:46:08.926Z",
    "endTIme": null,
    "estimateTime": 1800,
    "passingScore": 100,
    "version": 1.2
}
